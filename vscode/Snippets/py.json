{
	"acm template":{
		"scope": "python",
		"prefix": "pyacm",
		"body": [
			"packages = 1",
			"def I():",
			"    return input()",
			"def II():",
			"    return int(input())",
			"def MII():",
			"    return map(int, input().split())",
			"def LI():",
			"    return list(input().split())",
			"def LII():",
			"    return list(map(int, input().split()))",
			"def LFI():",
			"    return list(map(float, input().split()))",
			"def GMI():",
			"    return map(lambda x: int(x) - 1, input().split())",
			"def LGMI():",
			"    return list(map(lambda x: int(x) - 1, input().split()))",
			"",
			"if packages:",
			"    from io import BytesIO, IOBase",
			"    import random",
			"    import math",
			"    import os",
			"    import bisect",
			"    import typing",
			"    from collections import Counter, defaultdict, deque",
			"    from copy import deepcopy",
			"    from functools import cmp_to_key, lru_cache, reduce",
			"    from heapq import merge, heapify, heappop, heappush, heappushpop, nlargest, nsmallest",
			"    from itertools import accumulate, combinations, permutations, count, product",
			"    from operator import add, iand, ior, itemgetter, mul, xor",
			"    from string import ascii_lowercase, ascii_uppercase, ascii_letters",
			"    from typing import *",
			"",
			"",
			"",
			"#Life is short,You need Python",
			"",
			"RANDOM = random.randrange(2**62)",
			"",
			"",
			"def make_key(x):",
			"    return hash(x) ^ RANDOM",
			"",
			"t = II()",
			"",
			"def slove():",
			"    pass",
			"",
			"for _ in range(t):",
			"    slove()"
		]
	},

	"xor_basis":{
		"scope": "python",
		"prefix": "xor_basis",
		"body": [
			"class XorBasis:",
			"    def __init__(self, n: int):",
			"        self.b = [0] * n",
			"",
			"    def insert(self, x: int) -> None:",
			"        b = self.b",
			"        while x:",
			"            i = x.bit_length() - 1",
			"            if b[i] == 0:",
			"                b[i] = x",
			"                return",
			"            x ^= b[i]",
			"",
			"    def max_xor(self) -> int:",
			"        b = self.b",
			"        res = 0",
			"        for i in range(len(b) - 1, -1, -1):",
			"            if res ^ b[i] > res:",
			"                res ^= b[i]",
			"        return res"
		]
	},
    "fenwick_tree": {
        "scope": "python",
        "prefix": "fenwick_tree",
        "body": [	
            "class FenwickTree:",
            "    def __init__(self, n):",
            "        self.nums = [0] * n",
            "        self.tree = [0] * n",
			"",
			"",
			"    def batch_update(self,nums):",
            "        for i,x in enumerate(nums):",
			"            self.nums[i] = x",
			"            self.update(i,x)",
			"",
			
            "    def update(self, index: int, val: int) -> None:",
            "        d = val - self.nums[index]",
            "        self.nums[index] = val",
            "        i = index + 1",
            "        while i < len(self.tree) + 1:",
            "            self.tree[i-1] += d",
            "            i += i & -i",
            "",
            "    def prefix_sum(self, i: int) -> int:",
            "        s = 0",
            "        idx = i + 1",
            "        while idx:",
            "            s += self.tree[idx-1]",
            "            idx &= idx - 1",
            "        return s",
            "",
            "    def sum_range(self, left: int, right: int) -> int:",
            "        return self.prefix_sum(right) - self.prefix_sum(left-1)"
        ]
    },
	"fenwick_tree_2d": {
		"scope": "python",
		"prefix": "fenwick_tree_1d_2d",
		"body": [
			"class FenwickTree:",
			"    def __init__(self, n):",
			"        self.tree = [0] * n",
			"",
			"    def add(self, index: int, v: int) -> None:",
			"        i = index + 1",
			"        while i < len(self.tree) + 1:",
			"            self.tree[i - 1] += v",
			"            i += i & -i",
			"",
			"    def prefix_sum(self, i: int) -> int:",
			"        s = 0",
			"        idx = i + 1",
			"        while idx:",
			"            s += self.tree[idx - 1]",
			"            idx &= idx - 1",
			"        return s",
			"",
			"    def sum_range(self, left: int, right: int) -> int:",
			"        return self.prefix_sum(right) - self.prefix_sum(left - 1)",
			"",
			"",
			"class FenwickTree2D:",
			"    def __init__(self, m, n):",
			"        self.row = [FenwickTree(n) for _ in range(m)]",
			"        self.nums = [[0] * n for _ in range(m)]",
			"",
			"    def range_point_sum(self, x: int, y: int) -> int:",
			"        idx = x + 1",
			"        s = 0",
			"        while idx:",
			"            s += self.row[idx - 1].prefix_sum(y)",
			"            idx &= idx - 1",
			"        return s",
			"",
			"    def update_point(self, x: int, y: int, v: int) -> None:",
			"        d = v - self.nums[x][y]",
			"        self.nums[x][y] = v",
			"        i = x + 1",
			"        while i < len(self.row) + 1:",
			"            self.row[i - 1].add(y, d)",
			"            i += i & -i",
			"",
			"    # [(x1,y1):(x2,y2)]",
			"    def sum_range(self, x1: int, y1: int, x2: int, y2: int) -> int:",
			"        return self.range_point_sum(x2, y2) + self.range_point_sum(x1-1, y1-1) - self.range_point_sum(x2, y1-1) - self.range_point_sum(x1-1, y2)"
		]
	},
	"lazy_segment_tree": {
		"scope": "python",
		"prefix": "lazy_segment_tree",
		"body": [
			"class LazySegmentTree:",
			"    __slots__ = 'n', 'height', 'size', 'idval', 'idlazy', 'op', 'apply', 'compose', 'tree', 'lazy'",
			"    def __init__(self, nums, idval, idlazy, op, apply, compose):",
			"        self.n = len(nums)",
			"        self.height = (self.n-1).bit_length()",
			"        self.size = 1 << self.height",
			"        self.idval = idval",
			"        self.idlazy = idlazy",
			"        self.op = op",
			"        self.apply = apply",
			"        self.compose = compose",
			"",
			"        self.tree = [idval for _ in range(2 * self.size)]",
			"        self.tree[self.size:self.size+self.n] = nums",
			"        for i in range(self.size-1, 0, -1):",
			"            self.pushup(i)",
			"        self.lazy = [idlazy for _ in range(self.size)]",
			"",
			"    def pushup(self, rt):",
			"        self.tree[rt] = self.op(self.tree[rt*2], self.tree[rt*2+1])",
			"",
			"    def pushdown(self, rt):",
			"        if self.lazy[rt] == self.idlazy: return",
			"        self.modify(rt*2, self.lazy[rt])",
			"        self.modify(rt*2+1, self.lazy[rt])",
			"        self.lazy[rt] = self.idlazy",
			"",
			"    def set(self, idx, val):",
			"        idx += self.size",
			"        for i in range(self.height, 0, -1):",
			"            self.pushdown(idx >> i)",
			"        self.tree[idx] = val",
			"        for i in range(1, self.height + 1):",
			"            self.pushup(idx >> i)",
			"",
			"    def update(self, left, right, val):",
			"        if left > right: return",
			"        left += self.size",
			"        right += self.size",
			"",
			"        for i in range(self.height, 0, -1):",
			"            if left >> i << i != left:",
			"                self.pushdown(left >> i)",
			"            if (right+1) >> i << i != right+1:",
			"                self.pushdown(right >> i)",
			"",
			"        l, r = left, right",
			"        while left <= right:",
			"            if left & 1:",
			"                self.modify(left, val)",
			"                left += 1",
			"            if not right & 1:",
			"                self.modify(right, val)",
			"                right -= 1",
			"            left >>= 1",
			"            right >>= 1",
			"",
			"        left, right = l, r",
			"        for i in range(1, self.height + 1):",
			"            if left >> i << i != left:",
			"                self.pushup(left >> i)",
			"            if (right+1) >> i << i != right+1:",
			"                self.pushup(right >> i)",
			"",
			"    def modify(self, rt, val):",
			"        self.tree[rt] = self.apply(val, self.tree[rt])",
			"        if rt < self.size:",
			"            self.lazy[rt] = self.compose(val, self.lazy[rt])",
			"",
			"    def get(self, idx):",
			"        idx += self.size",
			"        for i in range(self.height, 0, -1):",
			"            self.pushdown(idx >> i)",
			"        return self.tree[idx]",
			"",
			"    def getall(self):",
			"        for idx in range(1, self.size):",
			"            self.pushdown(idx)",
			"        return self.tree[self.size:self.size+self.n]",
			"",
			"    def query(self, left, right):",
			"        if left > right: return self.idval",
			"        left += self.size",
			"        right += self.size",
			"",
			"        for i in range(self.height, 0, -1):",
			"            if left >> i << i != left:",
			"                self.pushdown(left >> i)",
			"            if (right+1) >> i << i != right+1:",
			"                self.pushdown(right >> i)",
			"",
			"        lres, rres = self.idval, self.idval",
			"        while left <= right:",
			"            if left & 1:",
			"                lres = self.op(lres, self.tree[left])",
			"                left += 1",
			"            if not right & 1:",
			"                rres = self.op(self.tree[right], rres)",
			"                right -= 1",
			"            left >>= 1",
			"            right >>= 1",
			"",
			"        return self.op(lres, rres)",
			"",
			"    def all(self):",
			"        return self.tree[1]",
			"",
			"    def find_right(self, left, f):",
			"        # 查找 left 右侧首个满足 f(query(left, idx)) 为真的下标",
			"        left += self.size",
			"        lres = self.idval",
			"        for i in range(self.height, 0, -1):",
			"            self.pushdown(left >> i)",
			"",
			"        while True:",
			"            while not left & 1:",
			"                left >>= 1",
			"            if f(self.op(lres, self.tree[left])):",
			"                while left < self.size:",
			"                    self.pushdown(left)",
			"                    left *= 2",
			"                    if not f(self.op(lres, self.tree[left])):",
			"                        lres = self.op(lres, self.tree[left])",
			"                        left += 1",
			"                return left - self.size",
			"            if left & (left + 1) == 0:",
			"                return self.n",
			"            lres = self.op(lres, self.tree[left])",
			"            left += 1",
			"",
			"    def find_left(self, right, f):",
			"        # 查找 right 左侧首个满足 f(query(idx, right)) 为真的下标",
			"        right += self.size",
			"        rres = self.idval",
			"        for i in range(self.height, 0, -1):",
			"            self.pushdown(right >> i)",
			"",
			"        while True:",
			"            while right > 1 and right & 1:",
			"                right >>= 1",
			"            if f(self.op(self.tree[right], rres)):",
			"                while right < self.size:",
			"                    self.pushdown(right)",
			"                    right = 2 * right + 1",
			"                    if not f(self.op(self.tree[right], rres)):",
			"                        rres = self.op(self.tree[right], rres)",
			"                        right -= 1",
			"                return right - self.size",
			"            if right & (right - 1) == 0:",
			"                return -1",
			"            rres = self.op(self.tree[right], rres)",
			"            right -= 1"
			]
		}
}
