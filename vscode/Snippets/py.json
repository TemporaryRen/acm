{
	"acm template":{
		"scope": "python",
		"prefix": "pyacm",
		"body": [
			"packages = 1",
			"def I():",
			"    return input()",
			"def II():",
			"    return int(input())",
			"def MII():",
			"    return map(int, input().split())",
			"def LI():",
			"    return list(input().split())",
			"def LII():",
			"    return list(map(int, input().split()))",
			"def LFI():",
			"    return list(map(float, input().split()))",
			"def GMI():",
			"    return map(lambda x: int(x) - 1, input().split())",
			"def LGMI():",
			"    return list(map(lambda x: int(x) - 1, input().split()))",
			"",
			"if packages:",
			"    from io import BytesIO, IOBase",
			"    import random",
			"    import math",
			"    import os",
			"    import bisect",
			"    import typing",
			"    from collections import Counter, defaultdict, deque",
			"    from copy import deepcopy",
			"    from functools import cmp_to_key, lru_cache, reduce",
			"    from heapq import merge, heapify, heappop, heappush, heappushpop, nlargest, nsmallest",
			"    from itertools import accumulate, combinations, permutations, count, product",
			"    from operator import add, iand, ior, itemgetter, mul, xor",
			"    from string import ascii_lowercase, ascii_uppercase, ascii_letters",
			"    from typing import *",
			"",
			"",
			"",
			"#Life is short,You need Python",
			"",
			"RANDOM = random.randrange(2**62)",
			"",
			"",
			"def make_key(x):",
			"    return hash(x) ^ RANDOM",
			"",
			"t = II()",
			"",
			"def slove():",
			"    pass",
			"",
			"for _ in range(t):",
			"    slove()"
		]
	},

	"xor_basis":{
		"scope": "python",
		"prefix": "xor_basis",
		"body": [
			"class XorBasis:",
			"    def __init__(self, n: int):",
			"        self.b = [0] * n",
			"",
			"    def insert(self, x: int) -> None:",
			"        b = self.b",
			"        while x:",
			"            i = x.bit_length() - 1",
			"            if b[i] == 0:",
			"                b[i] = x",
			"                return",
			"            x ^= b[i]",
			"",
			"    def max_xor(self) -> int:",
			"        b = self.b",
			"        res = 0",
			"        for i in range(len(b) - 1, -1, -1):",
			"            if res ^ b[i] > res:",
			"                res ^= b[i]",
			"        return res"
		]
	},
    "fenwick_tree": {
        "scope": "python",
        "prefix": "fenwick_tree",
        "body": [
            "class fenwick_tree:",
            "    def __init__(self, nums: List[int]):",
            "        n = len(nums)",
            "        self.nums = [0] * n",
            "        self.tree = [0] * n",
            "        for i, x in enumerate(nums):",
            "            self.update(i, x)",
            "",
            "    def update(self, index: int, val: int) -> None:",
            "        d = val - self.nums[index]",
            "        self.nums[index] = val",
            "        i = index + 1",
            "        while i < len(self.tree) + 1:",
            "            self.tree[i-1] += d",
            "            i += i & -i",
            "",
            "    def prefix_sum(self, i: int) -> int:",
            "        s = 0",
            "        idx = i + 1",
            "        while idx:",
            "            s += self.tree[idx-1]",
            "            idx &= idx - 1",
            "        return s",
            "",
            "    def sum_range(self, left: int, right: int) -> int:",
            "        return self.prefix_sum(right) - self.prefix_sum(left-1)"
        ]
    }
	
}
