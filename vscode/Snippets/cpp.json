{
	"acm contest template":{
		"prefix": ["acmz"],
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
	
			"#define forn(i, l, r) for(int i=l;i<r;i++)",
            "#define for0(i, r, l) for(int i=r;i>l;i--)",
			"#define all(a) a.begin(),a.end()",
			"#define forn(i, l, r) for(int i=l;i<r;i++)\n",
			"",
			"typedef long long ll;",
			"",
			"",
			"void solve(){",
			"}",
			"\n",
			"int main() {",
			"\tios_base::sync_with_stdio(false);",
			"\tcin.tie(nullptr);",
			"\tcout.tie(nullptr);",
			"\tint tc = 1;",
			"\tcin >> tc;",
			"\tfor (int t = 1; t <= tc; t++) {",
			"\t\tsolve();",
			"\t}",
			"\treturn 0;",
			"}"
	],
		"description": "acm contest template"
	},
	"string prefix array function":{
		"prefix": ["pi_fun"],
		"body": [
			"vector<int> pi_fun(string s) {",
			"\tint n = s.size();",
			"\tvector pi(n,0);",
			"\tfor (int i = 1; i < n; i++) {",
			"\t\tint j = pi[i - 1];",
			"\t\twhile (j > 0 && s[i] != s[j])j = pi[j - 1];",
			"\t\tif (s[i] == s[j]) ++j;",
			"\t\tpi[i] = j;",
			"\t}",
			"\treturn pi;",
			"}"

		],
		"description": "string prefix array function"
	},
	"kmp search":{
		"prefix": ["kmp_fun"],
		"body": [
			"vector<int> pi_fun(string s) {",
			"\tint n = s.size();",
			"\tvector pi(n,0);",
			"\tfor (int i = 1; i < n; i++) {",
			"\t\tint j = pi[i - 1];",
			"\t\twhile (j > 0 && s[i] != s[j])j = pi[j - 1];",
			"\t\tif (s[i] == s[j]) ++j;",
			"\t\tpi[i] = j;",
			"\t}",
			"\treturn pi;",
			"}",
			"\n",
			"void kmp(string s,string t){",
			"\tauto pi = pi_fun(t);",
			"\tint n = s.size();",
			"\tint m = t.size();",
			"\tint j = 0;",
			"\tfor(int i=0;i<n;i++){",
			"\t\tchar c = s[i];",
			"\t\twhile(j>0 && c!=t[j]) j = pi[j-1];",
			"\t\tj += (c==t[j]);",
			"\t\tif(j==m){",
			"\t\t\t//match success and do something",
			"\t\t}",
			"\t}",
			"}"
		],
		"description": "kmp function"
	},
	"Z function":{
		"prefix": ["Z_fun"],
		"body":[
			"vector<int> Z_fun(string s){",
			"\tint n = s.size();",
			"\tvector Z(n,0);",
			"\tfor(int j=1,l=0,r=0;j<n;j++){",
			"\t\tZ[j] = max(0,min(r-j+1,Z[j-l]));",
			"\t\twhile(j+Z[j]<n&&s[j+Z[j]]==s[Z[j]]) ++Z[j];",
			"\t\tif(j+Z[j]-1 > r){",
			"\t\t\tr = j+Z[j]-1;",
			"\t\t\tl = j;",
			"\t\t}",
			"\t}",
			"\treturn Z;",
			"}"
		],
		"description": "Z function"

	},
	"manacher":{
		"prefix": ["manacher"],
		"body":[
			"vector<int> manacher(const string& s){",
			"\tint n = s.size();",
			"\tvector ret(n,0);",
			"\tint l = 0, r = 0;",
			"\tfor(int i=1;i<n;i++){",
			"\t\tret[i] = max(0,min(ret[max(0,2*l-i)],r-i));",
			"\t\twhile(i+ret[i]+1<n&&i-ret[i]-1>=0&&s[i+ret[i]+1]==s[i-ret[i]-1]) ++ret[i];",
			"\t\tif(i+ret[i]>r){",
			"\t\t\tl = i;",
			"\t\t\tr = i+ret[i];",
			"\t\t}",
			"\t}",
			"\treturn ret;",
			"}"
		],
		"description": "manacher function"
	},
	"sparse table": {
		"prefix": ["sparse_table"],
		"body": [
			"template < typename T, typename Comp = std::less< T > >",
			"class sparse_table {",
			"private:",
			"\tstd::vector< T > data;",
			"\tstd::vector < std::vector < size_t > > table;",
			"\tvoid build_table();",
			"\tinline static unsigned mlog(size_t _n);",
			"public:",
			"\tconst size_t size() const { return data.size(); }",
			"\tsparse_table(const std::vector< T >& _data) : data(_data) {",
			"\t\tbuild_table();",
			"\t}",
			"\ttemplate < typename ItT >",
			"\tsparse_table(ItT begin, ItT end) {",
			"\t\twhile (begin != end) {",
			"\t\t\tdata.push_back(*begin);",
			"\t\t\t++begin;",
			"\t\t}",
			"\t\tbuild_table();",
			"\t}",
			"\tconst T& get_min(const size_t L, const size_t R) const;",
			"};",
			"",
			"template < typename T, typename Comp >",
			"void sparse_table< T, Comp >::build_table() {",
			"\tif (!data.size()) {",
			"\t\tthrow std::invalid_argument(\"Empty set is passed as a parameter.\");",
			"\t}",
			"\ttable.resize(1);",
			"\ttable[0].resize(data.size());",
			"\tfor (size_t i = 0; i < data.size(); ++i) {",
			"\t\ttable[0][i] = i;",
			"\t}",
			"\tunsigned pow = 1;",
			"\tconst unsigned max_pow = mlog(data.size());",
			"\ttable.resize(max_pow + 1);",
			"\tconst Comp cmp;",
			"\tfor (; pow <= max_pow; ++pow) {",
			"\t\tconst size_t cur_step_len = static_cast< size_t >(1) << pow,",
			"\t\t\tprev_step_len = static_cast< size_t >(1) << (pow - 1);",
			"\t\ttable[pow].resize(data.size() - cur_step_len + 1);",
			"\t\tfor (int i = 0; i <= data.size() - cur_step_len; ++i) {",
			"\t\t\ttable[pow][i] = cmp(data[table[pow - 1][i]], data[table[pow - 1][i + prev_step_len]]) ?",
			"\t\t\t\ttable[pow - 1][i] : table[pow - 1][i + prev_step_len];",
			"\t\t}",
			"\t}",
			"}",
			"",
			"template < typename T, typename Comp >",
			"inline unsigned sparse_table< T, Comp >::mlog(const size_t _n) {",
			"\tregister size_t n = _n, k = 0;",
			"\twhile ((static_cast< size_t >(1) << k) <= n) {",
			"\t\t++k;",
			"\t}",
			"\treturn k - 1;",
			"}",
			"",
			"template < typename T, typename Comp >",
			"const T& sparse_table< T, Comp >::get_min(const size_t L, const size_t R) const {",
			"\tif (L > data.size() || R == 0 || R > data.size()) {",
			"\t\tthrow std::out_of_range(\"Wrong index is used.\");",
			"\t}",
			"\tif (L >= R) {",
			"\t\tthrow std::invalid_argument(\"Wrong arguments in query.\");",
			"\t}",
			"\tconst unsigned pow = mlog(R - L);",
			"\tconst Comp cmp;",
			"\tconst size_t check_len = static_cast< size_t >(1) << pow;",
			"\treturn cmp(data[table[pow][L]], data[table[pow][R - check_len]]) ?",
			"\t\tdata[table[pow][L]] : data[table[pow][R - check_len]];",
			"}"
		],
		"description": "sparse table implementation"
	},
	"fenwick_tree_2d_template": {
		"prefix": ["fenwick_tree_2d"],
		"body": [
			"template <",
			"    typename T,",
			"    typename Add = std::plus<T>,",
			"    typename Sub = std::minus<T>",
			">",
			"",
			"class FenwickTree2D {",
			"public:",
			"    FenwickTree2D(int m, int n,",
			"                  T zero_ = T{},",
			"                  Add add_ = Add{},",
			"                  Sub sub_ = Sub{})",
			"        : m_(m), n_(n), zero_(zero_),",
			"          add_(add_), sub_(sub_),",
			"          data_(m_, std::vector<T>(n_, zero_)),",
			"          tree_(m_, std::vector<T>(n_, zero_)) {}",
			"",
			"    void update(int x, int y, T v) {",
			"        T delta = sub_(v, data_[x][y]);",
			"        data_[x][y] = v;",
			"        for (int i = x + 1; i <= m_; i += i & -i)",
			"            for (int j = y + 1; j <= n_; j += j & -j)",
			"                tree_[i - 1][j - 1] = add_(tree_[i - 1][j - 1], delta);",
			"    }",
			"",
			"    T prefix(int x, int y) const {",
			"        T res = zero_;",
			"        for (int i = x + 1; i; i -= i & -i)",
			"            for (int j = y + 1; j; j -= j & -j)",
			"                res = add_(res, tree_[i - 1][j - 1]);",
			"        return res;",
			"    }",
			"",
			"    T range(int x1, int y1, int x2, int y2) const {",
			"        T a = prefix(x2, y2);",
			"        T b = prefix(x1 - 1, y1 - 1);",
			"        T c = prefix(x2, y1 - 1);",
			"        T d = prefix(x1 - 1, y2);",
			"        return add_(add_(a, b), sub_(zero_, add_(c, d)));",
			"    }",
			"",
			"    T get(int x, int y) const { return data_[x][y]; }",
			"",
			"private:",
			"    int m_, n_;",
			"    T zero_;",
			"    Add add_;",
			"    Sub sub_;",
			"    std::vector<std::vector<T>> data_;  ",
			"    std::vector<std::vector<T>> tree_; ",
			"};"
		],
    	"description": "2D Fenwick Tree template (generic, supports custom add/sub)"
	},

	"Fast Modulo Exponentiation": {
		"prefix": "fmodpow",
		"body": [
			"// Fast modular exponentiation: a^b mod M",
			"ll fast_mod_pow(ll a, ll b, int M) {",
			"    ll res = 1LL;",
			"    while (b > 0) {",
			"        if (b & 1) res = res * a % M;",
			"        a = a * a % M;",
			"        b >>= 1;",
			"    }",
			"    return res;",
			"}"
		],
		"description": "Fast modular exponentiation function"
	},

	"Complete Modular Combination Template": {
        "prefix": "modcomb",
        "body": [
            "const int MOD = ${1:1e9 + 7};",       
            "const int MAX_N = ${2:1000005};" ,       
            "",
            "// ========== Global Arrays ==========",
            "vector<ll> fact(MAX_N), inv_fact(MAX_N);",
            "",
            "// ========== Modular Exponentiation ==========",
            "ll mod_pow(ll a, ll b, ll m = MOD) {",
            "    ll res = 1;",
            "    a %= m;",
            "    while (b > 0) {",
            "        if (b & 1) res = res * a % m;",
            "        a = a * a % m;",
            "        b >>= 1;",
            "    }",
            "    return res;",
            "}",
            "",
            "// ========== Precomputation ==========",
            "void precompute() {",
            "    // Factorials",
            "    fact[0] = 1;",
            "    for (int i = 1; i < MAX_N; i++) {",
            "        fact[i] = fact[i-1] * i % MOD;",
            "    }",
            "    ",
            "    // Inverse factorials using Fermat's Little Theorem",
            "    inv_fact[MAX_N-1] = mod_pow(fact[MAX_N-1], MOD-2);",
            "    for (int i = MAX_N-2; i >= 0; i--) {",
            "        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD;",
            "    }",
            "}",
            "",
            "// ========== Combination Functions ==========",
            "ll nCr(int n, int r) {",
            "    if (r < 0 || r > n) return 0;",
            "    return fact[n] * inv_fact[r] % MOD * inv_fact[n-r] % MOD;",
            "}",
            "",
            "ll nPr(int n, int r) {",
            "    if (r < 0 || r > n) return 0;",
            "    return fact[n] * inv_fact[n-r] % MOD;",
            "}",
            "",
            "// Combination with Lucas Theorem (for large n, small prime MOD)",
            "ll nCr_lucas(ll n, ll r) {",
            "    if (r < 0 || r > n) return 0;",
            "    if (r == 0) return 1;",
            "    return nCr(n % MOD, r % MOD) * nCr_lucas(n / MOD, r / MOD) % MOD;",
            "}",
            "",
            "// ========== Modular Inverse ==========",
            "ll mod_inverse(ll a) {",
            "    return mod_pow(a, MOD-2);",
            "}",
            "",
            "// ========== Main for Testing ==========",
            "int main() {",
            "    ios::sync_with_stdio(false);",
            "    cin.tie(nullptr);",
            "    ",
            "    // Precompute factorials",
            "    precompute();",
            "    ",
            "    // Example usage",
            "    int n = 10, k = 3;",
            "    cout << \"C(\" << n << \", \" << k << \") = \" << nCr(n, k) << endl;",
            "    cout << \"P(\" << n << \", \" << k << \") = \" << nPr(n, k) << endl;",
            "    ",
            "    return 0;",
            "}"
        ],
        "description": "Complete modular combination template with precomputation"
    }
	
}
